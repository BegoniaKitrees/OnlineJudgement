问题描述：
现在有n个依次增大的盘子，放在a柱子上，想要移动到c柱子上去，现在有b柱子可以借用。
规则：
小盘子只能放在大盘子之上
一次只能移动一个盘子
思路：
从最后开始考虑，为了将最大的一个盘子从a移动到c，首先要保证n-1个盘子现在在b柱子上，
这样可以直接将最大的盘子从a移动到c上去。
然后，现在a柱子空了，b柱子上有n-1个盘子，c柱子上有一个已经成功归位的最大的盘子，
现在需要做的是将b柱子最下面的当前最大的盘子移动到c上去；
这时，a柱子变成了临时借用的，b变为起始柱子，操作和上面一样。
第一步：将n-1个盘子从a柱移动至b柱（借助c柱为过渡柱）
第二步：将a柱底下最大的盘子移动至c柱
第三步：将b柱的n-1个盘子移至c柱（借助a柱为过渡柱）
实现：
void Hanio(int n, char start_pos, char tran_pos, char end_pos)
{
	if (n == 1) {//当n==1时，只需要将最大的盘子从起始移动到目标即可
		move(n, start_pos, end_pos);
	}
	else {
		Hanio(n - 1, start_pos, end_pos, tran_pos);//递归处理，一开始的时候，先将n-1个盘子移动到过渡柱上，这里的终点目标为过渡柱
		move(n, start_pos, end_pos);//然后再将底下的大盘子移动到目标柱子
		Hanio(n - 1, tran_pos, start_pos, end_pos);//然后重复上述步骤，此时在过渡柱上的n-1个盘子，这时，原来的起始柱变为过渡柱，过渡柱变为起始柱
	}
}
总结：
对于n个盘子，移动的总步数为2^n -1